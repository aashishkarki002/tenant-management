import PushSubscription from "./push.Model.js";
import { sendPushToAdmin } from "../../config/webpush.js";

export const sendTestNotification = async (req, res) => {
  try {
    const { title, body } = req.body || {};
    const titleText = title ?? "Test";
    const bodyText = body ?? "Test notification";
    const adminIds = await PushSubscription.distinct("admin");
    if (adminIds.length === 0) {
      return res
        .status(200)
        .json({ message: "No push subscriptions; nothing sent.", sent: 0 });
    }
    for (const adminId of adminIds) {
      await sendPushToAdmin(adminId, {
        title: titleText,
        body: bodyText,
        data: {},
      });
    }
    res.status(200).json({
      message: "Test notification sent to all subscribers.",
      sent: adminIds.length,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to send test notification",
      error: error.message,
    });
  }
};

// ── Initial subscribe — requires auth to bind endpoint → adminId ──────────────
export const savePushSubscription = async (req, res) => {
  try {
    const { subscription } = req.body;
    if (
      !subscription?.endpoint ||
      !subscription?.keys?.p256dh ||
      !subscription?.keys?.auth
    ) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid subscription object" });
    }

    await PushSubscription.findOneAndUpdate(
      { "subscription.endpoint": subscription.endpoint },
      { admin: req.admin.id, subscription },
      { upsert: true, new: true },
    );

    res.status(201).json({ success: true, message: "Push subscription saved" });
  } catch (error) {
    res
      .status(500)
      .json({ success: false, message: "Failed to save subscription", error });
  }
};

// ── Token-free renewal — endpoint URL itself proves prior registration ─────────
//
// How it's safe: the endpoint is a long random URL generated by the browser's
// push service (FCM/Mozilla). Only a device that previously subscribed and was
// saved by an authenticated /subscribe call knows this URL. We never expose
// endpoints to clients, so possession = proof. We only UPDATE keys — we never
// create a new admin association, and we never return any data.
export const renewPushSubscription = async (req, res) => {
  try {
    const { subscription } = req.body;

    if (
      !subscription?.endpoint ||
      !subscription?.keys?.p256dh ||
      !subscription?.keys?.auth
    ) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid subscription object" });
    }

    // Only update if this endpoint already exists — never upsert (no auth = no new admin binding)
    const existing = await PushSubscription.findOneAndUpdate(
      { "subscription.endpoint": subscription.endpoint },
      { $set: { subscription } }, // only refresh the keys, admin field is untouched
      { new: true },
    );

    if (!existing) {
      // Unknown endpoint — cannot associate to an admin without auth.
      // Return 200 (not 404) so the hook knows to fall back to full /subscribe.
      return res.status(200).json({
        success: false,
        reason: "unknown_endpoint",
        message: "Subscription not found — re-subscribe required",
      });
    }

    res.status(200).json({ success: true, message: "Subscription renewed" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to renew subscription",
      error: error.message,
    });
  }
};

export const deletePushSubscription = async (req, res) => {
  try {
    const { endpoint } = req.body;
    if (!endpoint)
      return res
        .status(400)
        .json({ success: false, message: "endpoint required" });

    await PushSubscription.deleteOne({
      "subscription.endpoint": endpoint,
      admin: req.admin.id,
    });

    res.status(200).json({ success: true, message: "Subscription removed" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to remove subscription",
      error,
    });
  }
};
